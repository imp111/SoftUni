Lecture 1: Inheritance (Extending Classes):

Hierarchy

	Superclass (Parent, Base Class) 
		
		- The class giving its members to its child class

	Subclass (Child, Derived Class) 
		
		- The class taking members from its base class


	Subclass : Superclass (subclass inherits superclass (all its properties, methods and fields)

Reusing constructors

	Constructors are not inherited, so they have to be reused by the child classes using the base keyword.

		Student : Person
		public Student(string name, School school) : base(name)
		{
			...
		}

	Derived class instance contains instance of its base class.

		In C#, there is not multiple inheritance, one class can inherit only one class, while one class can be inherited by a lot of classes.
		The only way to achieve multiple inheritance is by Interfaces.


Access to Base Class Members
	
	Using the base keyword, we can access members of the base class.

	- base.MethodName
	- base.Property
	- base.field


Reusing Classes (Reusing Code at Class Lever)
	
	Inheritance and Access Modifiers 
		
		- Public and Protected members can be accessed by the Derived Classes
		- Internal members are accessed in the same assembly
		- Private members are inherited, but not visible in the Derived Classes

	Shadowing Variables - Derived classes can hide superclass variables
	
	class Person { protected int weight; }
	class Patient : Person
	{
		protected float weight; 	- hides int weight
		public void Method()
		{
			double weight = 0.5d;	- hides float weight
		}
	}


	Accessing Shadowed Variables
	
	class Person { protected int weight; }
	class Patient : Person
	{
		protected float weight; 	- Local Variable
		public void Method()
		{
			double weight = 0.5d;
			this.weight = 0.6f;	- Accessing the instance member
			base.weight = 1;	- Accessing the base class member
		}
	}
	
	
	Virtual Methods - defines a method that can be overriden (virtual, overidde keywords)

		public class Animal { public virtual void Eat() {...} }
		public class Dog : Animal { public override void Eat() {...} }


	Sealed Modifier (sealed keyword) - the sealed modifier prevents other classes from inheriting from it
	
		- Sealed can be used on a method or a property in a Base Class
		- It enables you to allow classes to derive from your class
		- Prevents the overriding of specific virtual methods and properties


	
Types of Class Reuse (Extension (Inheritance) and Composition)

	Extension (Inheritance) (IS-A relation)
	
		- Duplicate code is error prone
		- Reuse classes through extention (inheritance)
		- Sometimes the only way

	Composition (HAS-A relation)

		- using classes to define classes

		class Laptop
		{
			Monitor monitor;	- reusing classes
			Keyboard keyboard;	- reusing classes
		}


Summary

	- Inheritance is a powerful tool for code reuse
	- Subclass inherits members from Superclass and can override methods
	- Look for classes with the same role
	- Look for IS-A and IS-A-SUBSTITUTE
	- Consider Composition and Delegation



Lecture 2: Encapsulation (Hiding Implementation):

	- Process of wrapping code and data together into a single unit
	- Flexibility and extensibility of the code
	- Reduces complexity
	- Structural changes remain local
	- Allows validation and data binding

	Example

	- Fields should be private
	- Properties should be public

	class Person
	{
		private string name;
		private int age;
		
		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public int Age
		{
			get { return age; }
			set { age = value; }
		}

		public Person(string name, int age)
		{
			Name = name;
			Age = age;
		}
	}


	Keyword this

	- Reference to the current object
	- Refers to the current instance of the class
	- Can be passed as a parameter to other methods
	- Can be returned from method
	- Can invoke current class methods


Access Modifiers (Visability of Class Members)

	- private - the main way to perform encapsulation and hide data from the outside world

		private string name;
		public Person(string name)
		{
			this.name = name;
		}
		
		- The default field and method modifier is private
		- Avoid declaring private classes and interfaces, accessible only within the declared class itself
		
	- public - the most permissive access level
		
		public class Person
		{
			public string Name { get; set; }
			public int Age { get; set; }
		}

		- There are no restrictions on accessing public members
		- To access class directly from a namespace, use the using keyword to include the namespace

	- internal - is the default class access modifier, and is accessible to any other class in the same project

	- protected

	- internal protected


Validation

	- Validation in Setters (used for simple data validation) - callers of your methods should take care of handling exceptions
		
		public decimal Salary
		{
			get { return this.salary }
			set { if (salary < 650) { throw new ArgumentExeption(...); } this.salary = value; }
		}
	
	- Validation in Constructors - Constructors use private setters with validation logic and it guarantees a valid state of the object after its creation

		public Person(string firstName, string lastName, int age)
		{
			this.FirstName = firstName;		- validation happens inside the setter
			this.LastName = lastName;
			this.Age = age;
		}

Mutable vs Immutable Objects

	Mutable Objects					Immutable Objects
	Changeable					Unchangeable (read-only)
	Uses the same memory location			Create new memory every time they're modified
	StringBuilder					string
	List						Tuples

	- Mutable Fields - private mutable fields are still not encapsulated, in this case you can access the field methods through the getter

		class Team
		{
			private List<Person> players;
			public List<Person> Players { get { return this.players; } }
		}

	- Immutable Fields - you can use IReadOnlyColletion to encapsulate collections

		public class Team
		{
			private List<Person players;
			public IReadOnlyCollection<Person> Players
			{
				get { return this.players.AsReadOnly(); }
			}

			public void AddPlayer(Person player) => this.players.Add(player); // mutable now
		}


Summary

	- Encapsulation
		- Hides implementation
		- Reduces complexity
		- Ensures that structural changes remain local
	
	- Mutable and Immutable objects


Lecture 3: Interfaces and Abstraction (Interfaces vs Abstract Classes, Abstraction vs Encapsulation):

Abstraction (Achieving Abstraction)
	
	Abstraction - preserving information, relevant in a given context, and forgetting information that is irrelevant in that context

		- It means ignoring irrelevant features, properties, or methods and emphasizing the ones relevant to the context of the project we develop
		- Abstraction helps managing complexity
		- Abstraction also lets you focus on what the object does instead of how it does it

	The main ways to achieve abstractions are
		- Interfaces
			public interface IAnimal {}

		- Abstract classes
			public abstract class Mammal {}

		class Person : Mammal, IAnimal {}


	Abstraction vs Encapsulation
	
		- Abstraction									- Encapsulation
		- Process of hiding the implementation details 					- Used to hide the code and data inside a single unit
		and showing only fucntionality to the user					to protect the data from the outside world
		- Achieved with interfaces and abstract classes					- Achieved with access modifiers (private, public, protected)
	

Working with Interfaces
	
	public interface IPrintable	// interface - the keyword that specified to the compiler that we are using interface, IPrintable - name starts with I (this is the convention)
	{
		void Print();
	}
	
	The Interface is afterwards inherited by a class, and in that class is then written the implementation of the interface (the code for the Print() method, etc.)

	public class Document : IPrintable
	{
		public void Print()
		{
			Console.WriteLine("Printing");
		}
	}

	Interfaces
		- Contains signatures of methods, properties, events or indexers (only the types and names, they should all have public access modifiers)
		- A class can inherit one or more base interfaces, and interfaces can inherit interfaces
		- When a base type list contains a base class and interfaces, the base class must come first in the list
		- A class that implements an interface can explicitly implement memebers of that interface
			- An explicitly implemented member cannot be accessed through a class instace, but only through the interface

	
	Multiple Implementation
		- Relationship between classes and interfaces
			Class -> 	extends 	-> Class
			Class -> 	implements 	-> Interface
			Interface ->	extends		-> Interface

		- Multiple implementation and inheritance
			Class -> 	implements	-> Interface
							-> Interface

			Interface ->	extends		-> Interface
							-> Interface


Working with Abstract Classes
	
	Abstract Classes
	- Cannot be instantiated
	- May contain abstract methods and accessors
	- Must provide implementation for all inherited interface members
	- Implementing an interface might map the interface methods onto abstract methods
	
	Abstract Methods
	- An abstract method is implicitly a virtual method
	- Abstract method declarations are only permitted in abstract classes
	- An abstract method declaration provides no actual implementation

		public abstract void Build();



Interfaces vs Abstract Classes

	- Interface										- Abstract Class
	- A class may implement	several interfaces						- May inherit only one abstract class
	- Cannot have access modifiers,	everything is assumed as public				- Can provide implementation and/or just the signature that have to be overridden
	- Cannot provide any code, just the signature						- Can contain access modifiers for the fields, function, properties
	- Fields and constants can't be defined							- Fields and constants can be defined
	- If we add a new method we have to track down all the implementations			- If we add a new method we have the option of providing default implementation
	of the interface and define implementation for the new method 				and therefore all the existing code might work properly


Summary
	- Abstraction
	- How do we achieve abstraction
	- Interfaces
	- Abstract classes
















