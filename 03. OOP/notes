Lecture 1: Inheritance (Extending Classes):

Hierarchy

	Superclass (Parent, Base Class) 
		
		- The class giving its members to its child class

	Subclass (Child, Derived Class) 
		
		- The class taking members from its base class


	Subclass : Superclass (subclass inherits superclass (all its properties, methods and fields)

Reusing constructors

	Constructors are not inherited, so they have to be reused by the child classes using the base keyword.

		Student : Person
		public Student(string name, School school) : base(name)
		{
			...
		}

	Derived class instance contains instance of its base class.

		In C#, there is not multiple inheritance, one class can inherit only one class, while one class can be inherited by a lot of classes.
		The only way to achieve multiple inheritance is by Interfaces.


Access to Base Class Members
	
	Using the base keyword, we can access members of the base class.

	- base.MethodName
	- base.Property
	- base.field


Reusing Classes (Reusing Code at Class Lever)
	
	Inheritance and Access Modifiers 
		
		- Public and Protected members can be accessed by the Derived Classes
		- Internal members are accessed in the same assembly
		- Private members are inherited, but not visible in the Derived Classes

	Shadowing Variables - Derived classes can hide superclass variables
	
	class Person { protected int weight; }
	class Patient : Person
	{
		protected float weight; 	- hides int weight
		public void Method()
		{
			double weight = 0.5d;	- hides float weight
		}
	}


	Accessing Shadowed Variables
	
	class Person { protected int weight; }
	class Patient : Person
	{
		protected float weight; 	- Local Variable
		public void Method()
		{
			double weight = 0.5d;
			this.weight = 0.6f;	- Accessing the instance member
			base.weight = 1;	- Accessing the base class member
		}
	}
	
	
	Virtual Methods - defines a method that can be overriden (virtual, overidde keywords)

		public class Animal { public virtual void Eat() {...} }
		public class Dog : Animal { public override void Eat() {...} }


	Sealed Modifier (sealed keyword) - the sealed modifier prevents other classes from inheriting from it
	
		- Sealed can be used on a method or a property in a Base Class
		- It enables you to allow classes to derive from your class
		- Prevents the overriding of specific virtual methods and properties


	
Types of Class Reuse (Extension (Inheritance) and Composition)

	Extension (Inheritance) (IS-A relation)
	
		- Duplicate code is error prone
		- Reuse classes through extention (inheritance)
		- Sometimes the only way

	Composition (HAS-A relation)

		- using classes to define classes

		class Laptop
		{
			Monitor monitor;	- reusing classes
			Keyboard keyboard;	- reusing classes
		}


Summary

	- Inheritance is a powerful tool for code reuse
	- Subclass inherits members from Superclass and can override methods
	- Look for classes with the same role
	- Look for IS-A and IS-A-SUBSTITUTE
	- Consider Composition and Delegation



Lecture 2: Encapsulation (Hiding Implementation):

	- Process of wrapping code and data together into a single unit
	- Flexibility and extensibility of the code
	- Reduces complexity
	- Structural changes remain local
	- Allows validation and data binding

	Example

	- Fields should be private
	- Properties should be public

	class Person
	{
		private string name;
		private int age;
		
		public string Name
		{
			get { return name; }
			set { name = value; }
		}

		public int Age
		{
			get { return age; }
			set { age = value; }
		}

		public Person(string name, int age)
		{
			Name = name;
			Age = age;
		}
	}


	Keyword this

	- Reference to the current object
	- Refers to the current instance of the class
	- Can be passed as a parameter to other methods
	- Can be returned from method
	- Can invoke current class methods


Access Modifiers (Visability of Class Members)

	- private - the main way to perform encapsulation and hide data from the outside world

		private string name;
		public Person(string name)
		{
			this.name = name;
		}
		
		- The default field and method modifier is private
		- Avoid declaring private classes and interfaces, accessible only within the declared class itself
		
	- public - the most permissive access level
		
		public class Person
		{
			public string Name { get; set; }
			public int Age { get; set; }
		}

		- There are no restrictions on accessing public members
		- To access class directly from a namespace, use the using keyword to include the namespace

	- internal - is the default class access modifier, and is accessible to any other class in the same project

	- protected

	- internal protected


Validation

	- Validation in Setters (used for simple data validation) - callers of your methods should take care of handling exceptions
		
		public decimal Salary
		{
			get { return this.salary }
			set { if (salary < 650) { throw new ArgumentExeption(...); } this.salary = value; }
		}
	
	- Validation in Constructors - Constructors use private setters with validation logic and it guarantees a valid state of the object after its creation

		public Person(string firstName, string lastName, int age)
		{
			this.FirstName = firstName;		- validation happens inside the setter
			this.LastName = lastName;
			this.Age = age;
		}

Mutable vs Immutable Objects

	Mutable Objects					Immutable Objects
	Changeable					Unchangeable (read-only)
	Uses the same memory location			Create new memory every time they're modified
	StringBuilder					string
	List						Tuples

	- Mutable Fields - private mutable fields are still not encapsulated, in this case you can access the field methods through the getter

		class Team
		{
			private List<Person> players;
			public List<Person> Players { get { return this.players; } }
		}

	- Immutable Fields - you can use IReadOnlyColletion to encapsulate collections

		public class Team
		{
			private List<Person players;
			public IReadOnlyCollection<Person> Players
			{
				get { return this.players.AsReadOnly(); }
			}

			public void AddPlayer(Person player) => this.players.Add(player); // mutable now
		}


Summary

	- Encapsulation
		- Hides implementation
		- Reduces complexity
		- Ensures that structural changes remain local
	
	- Mutable and Immutable objects


Lecture 3: Interfaces and Abstraction (Interfaces vs Abstract Classes, Abstraction vs Encapsulation):

Abstraction (Achieving Abstraction)
	
	Abstraction - preserving information, relevant in a given context, and forgetting information that is irrelevant in that context

		- It means ignoring irrelevant features, properties, or methods and emphasizing the ones relevant to the context of the project we develop
		- Abstraction helps managing complexity
		- Abstraction also lets you focus on what the object does instead of how it does it

	The main ways to achieve abstractions are
		- Interfaces
			public interface IAnimal {}

		- Abstract classes
			public abstract class Mammal {}

		class Person : Mammal, IAnimal {}


	Abstraction vs Encapsulation
	
		- Abstraction									- Encapsulation
		- Process of hiding the implementation details 					- Used to hide the code and data inside a single unit
		and showing only fucntionality to the user					to protect the data from the outside world
		- Achieved with interfaces and abstract classes					- Achieved with access modifiers (private, public, protected)
	

Working with Interfaces
	
	public interface IPrintable	// interface - the keyword that specified to the compiler that we are using interface, IPrintable - name starts with I (this is the convention)
	{
		void Print();
	}
	
	The Interface is afterwards inherited by a class, and in that class is then written the implementation of the interface (the code for the Print() method, etc.)

	public class Document : IPrintable
	{
		public void Print()
		{
			Console.WriteLine("Printing");
		}
	}

	Interfaces
		- Contains signatures of methods, properties, events or indexers (only the types and names, they should all have public access modifiers)
		- A class can inherit one or more base interfaces, and interfaces can inherit interfaces
		- When a base type list contains a base class and interfaces, the base class must come first in the list
		- A class that implements an interface can explicitly implement memebers of that interface
			- An explicitly implemented member cannot be accessed through a class instace, but only through the interface

	
	Multiple Implementation
		- Relationship between classes and interfaces
			Class -> 	extends 	-> Class
			Class -> 	implements 	-> Interface
			Interface ->	extends		-> Interface

		- Multiple implementation and inheritance
			Class -> 	implements	-> Interface
							-> Interface

			Interface ->	extends		-> Interface
							-> Interface


Working with Abstract Classes
	
	Abstract Classes
	- Cannot be instantiated
	- May contain abstract methods and accessors
	- Must provide implementation for all inherited interface members
	- Implementing an interface might map the interface methods onto abstract methods
	
	Abstract Methods
	- An abstract method is implicitly a virtual method
	- Abstract method declarations are only permitted in abstract classes
	- An abstract method declaration provides no actual implementation

		public abstract void Build();

	
	Example

	public interface ICar 
	{
		string Model { get; }
		string Color { get; }
		void Start();
		void Stop();
	}

	public interface IElectricCar
	{
		int Batteries { get; }
	}

	public interface InternalCombustionEngine
	{
		int Fuel { get; }
	}

	public class Tesla : ICar, IElectricCar
	{
		public string Model { get; private set; }
		public string Color { get; private set; }
		public int Batteries { get; private set; }
		public Tesla(string model, string color, int batteries)
		{
			Model = model;
			Color = color;
			Batteries = batteries;
		}

		public void Start()
		{
			Console.Writeline($"Battery Percentage: {Batteries}");
			Console.WriteLine($"The car model: {Model} with color: {Color} started!");
		}

		public void Stop()
		{
			Console.WriteLine($"Battery Percentage: {Batteries}");
			Console.WriteLine($"The car model: {Model} with color: {Color} stopped!");
		}
	}

	public class Seat : ICar, InternalCombustionEngine
	{
		public string Model { get; private set; }
		public string Color { get; private set; }
		public int Fuel { get; private set; }
		public Seat(string model, string color, int fuel)
		{
			Model = model;
			Color = color;
			Fuel = fuel;
		}

		public void Start()
		{
			Console.Writeline($"Fuel Percentage: {Fuel}");
			Console.WriteLine($"The car model: {Model} with color: {Color} started!");
		}

		public void Stop()
		{
			Console.WriteLine($"Fuel Percentage: {Fuel}");
			Console.WriteLine($"The car model: {Model} with color: {Color} stopped!");
		}
	}

Interfaces vs Abstract Classes

	- Interface										- Abstract Class
	- A class may implement	several interfaces						- May inherit only one abstract class
	- Cannot have access modifiers,	everything is assumed as public				- Can provide implementation and/or just the signature that have to be overridden
	- Cannot provide any code, just the signature						- Can contain access modifiers for the fields, function, properties
	- Fields and constants can't be defined							- Fields and constants can be defined
	- If we add a new method we have to track down all the implementations			- If we add a new method we have the option of providing default implementation
	of the interface and define implementation for the new method 				and therefore all the existing code might work properly


Summary
	- Abstraction
	- How do we achieve abstraction
	- Interfaces
	- Abstract classes


Lecture 4: Polymorphism (Polymorphism, Override and Overload Methods):

	Polymorphism (Poly - many, morphe - forms) 
		- This is something similar to a word having several different meanings depending on the context
		- Polymorphism is often referred to as the third pillar of OOP, after encapsulation and inheritance

	Polymorphism is the ability of an object to take many forms 
		
		public interface IAnimal {}
		public abstract class Mammal {}
		public class Person : Mammal, IAnimal {}

		Person IS-A Person
		Person IS-AN Object
		Person IS-AN Animal
		Person IS-A Mammal


	Variable Type and Data Type

		- Variable Type is the compile-time type of the variable
		- Data Type is the actual runtime type of the variable

		- If you need an object method, you need to cast it or override it

		public class Person : Mammal, IAnimal {}
		object objPerson = new Person();
		IAnimal person = new Person();
		Mammal mammal = new Person();
		Person person = new Person();


	Keyword "is"
		
		- Runtime check if an object is an instance of a specific class
		
		public class Person : Mammal, IAnimal {}
		IAnimal person = new Person();
		Mammal personOne = new Person();
		Person personTwo = new Person();
		if (person is Person)	// check object type of person
		{
			((Person)person).getSalary();	// cast to object type and use its methods
		}

	Keyword "is" Type Pattern

		- Type pattern - tests whether an expression ca nbe converted to a specified type and casts it to a variable of that type

		public class Person : Mammal, IAnimal {}
		IAnimal person = new Person();
		Mammal personOne = new Person();
		Person personTwo = new Person();
		if (personOne is Person person)		// check object is of type person and casts it 
		{
			person.getSalary();		// uses its methods
		}

	Keyword "is" Constant Pattern

		- When performing pattern matching with the constant pattern, "is" tests whether an expression equal a specified constant

		- Checking for null can be performed using the constant pattern

		int i = 0;
		int min = 0, max = 10;
		while (true)
		{
			Console.WriteLine($"i is {i}");
			i++;

			if (i is max or min) break;
		}

	Keyword "is" var Pattern

		- A pattern match with the var pattern always succeeds

			Enumerable.Range(0, 100).Where(x => x % 10 is var r && r >= 1 && r <= 3)

		- The value of expr is always assigned to a local variable named varname
		- varname is a variable of the same type as expr
		- Note that if expr is null, the is expression still is true and assigns null to varname


	Keyword "as"
		
		- You can use the "as" operator to perform certain types of converions between compatible reference types

		public class Person : Mammal, IAnimal {}

		IAnimal person = new Person();
		Mammal personOne = new Person();
		Person personTwo;
		
		personTwo = personOne as Person;	// Convert Mammal to Person

		if (personTwo is Person)	// Check if conversion is successful
		{
			Console.WriteLine("successful conversion");
		}


	Types of Polymorphism

		-  Compile-time 
			
			- Also known as Static Polymorphism
			- Argument lists could differ in
				- Number of parameters			int Sum(int a, int b);
				- Data type of parameters		double Sum(double a, double b, double c);
				- Order of parameters			int Sum(double c, double a, double c);

			int Sum(int a, int b, int c);
			double Sum(double a, double b); // method overloading
			
			
			Rules for Overloading a Method
				- Name should be the same
				- Signature must be different
					- Number of arguments
					- Data type of arguments
					- Order of arguments
				- Return type is not a part of its signature
				- Overloading can take place in the same class or in its sub-classes
				- Constructors can be overloaded


		- Runtime
			
			Has two distinct apsects
			- At run time, objects of a derived class may be treated as objects of a base class in places,
			such as method parameters and collections or arrays
				- When this occurs, the object's declared type is no longer identical to its run-time type
			- Base classes may define and implement virtual methods
				- Derived classes can override
				- They provide their own definition and implementation
			- At run-time, the CLR looks up the run-time type of the object and invokes that override of the virtual method
			- Also known as Dynamic Polymorphism
				
				public class Rectangle {
					public virtual double Area() {
						return this.a * this.b;
					}
				}

				public class Square : Rectangle {
					public override double Area() {
						return this.a * this.a; 	// Method overriding
					}
				}
			
			- Usage of override method

				public static void Main()
				{
					Rectangle rect = new Rectangle(3.0, 4.0);
					Rectangle square = new Square(4.0);

					Console.WriteLine(rect.Area());	  // 12.0	Method overriding
					Console.WriteLine(square.Area()); // 16.0
				}
			
			- Rules of Overriding Method 

				- Overriding must take place in any sub-classes
				- The overriding method and the base must have the same return type and the same signature
				- Base method must have the virtual keyword
				- Overriding method must have the abstract or override keyword
				- Private and static methods cannot be overriden
				- Virtual members can use base keyword to call the base class

			- Virtual Members
					
				- Virtual members remain virtual indefinitely
				- A derived class can stop virtual inheritance by declaring an override as sealed
					- Sealed methods can be replaced by derived classes by using the new keyword
				- The override modifer extends the base class virtual method
					- The new modifier hides an accessible base class method

			public class Shape {}
			public class Circle : Shape {}
			public static void Main()
			{
				Shape shape = new Circle();
				shape.Draw();
			}


	Summary
		- Polymorphism - definition and types
		- is keyword
		- as keyword
		- Overload methods
		- Override methods


Lecture 5: Exception and Error Handling (Handling Errors During the Program Execution):

	Exceptions 
		- Simplify code construction and maintenance
		- Allow the problematic situations to be prcoessed at multiple levels
		- Exception objects have detailed information about the error
	

		The System.Exception Class
		- In C#, Exceptions are objects
		- System.Exception class is the base for all exceptions in CLR
			- Contains information about the cause of the error
			- Message - a text description of the exception
				- StackTrace - the snapshot of the stack at the moment of exception throwing
				- InnerException - exception that caused the current exception (if any)


		Exception Hierarchy in .NET

		1. System.Exception						(-> = inherits)
		2. System.SystemException, CustomException 			(SystemException, CustomException -> Exception) 
		3. System.NullReferenceException, System.FormatException 	(NullReferenceException, FormatException -> SystemException)
		4. System.ArithmeticException					(ArithmeticException -> SystemException)
		5. System.DividedByZeroException, System.OverflowException	(DividedByZeroException, OverflowEXception -> ArithmeticException)
		
		Types of exceptions
		- .NET exceptions inherit from System.Exception
		- The system exceptions inherit from System.SystemException
			- System.ArgumentException
			- System.FormatException
			- System.NullReferenceException
			- System.OutOfMemoryException
			- System.StackOverflowException
		- User-defined exceptions should be inherited from Syste.Exception class.


	Handling Exceptions (Catching and Processing Erros)

		- Exceptions are handled by the try-catch construction

			try
			{
				// Code that can raise an exception
			}
			catch (SomeException)
			{
				// How to handle the caught exception
			}


		- Catch blocks can be used multiple times to catch different exception types

			string s = Console.ReadLine();
			try 
			{
  				int.Parse(s);
    				Console.WriteLine("You entered a valid Int32 number {0}.", s);
			}
			catch (FormatException) 
			{
  				Console.WriteLine("Invalid integer number!");
			}
			catch (OverflowException) 
			{
  				Console.WriteLine("The number is too big to fit in Int32!");
			}
	

		- When catching an exception of a particular class, all its inheritors (child exceptions) are caught too 
		(if we try, catch an ArithmeticException, we are also trying to catch, DivideByZero and Overflow)
		
			string str = Console.ReadLine();
			try {
  				Int32.Parse(str);
			}
			catch (Exception) {
  				Console.WriteLine("Cannot parse the number!");
			}
			catch (FormatException) {
  				Console.WriteLine("Invalid integer number!");
			}
			catch (OverflowException) {
  				Console.WriteLine("The number is too big to fit in Int32!");
			}

			- If this case, the FormatException and OverflowException are going to be unreachable, because the two exceptions are inherited 
			by the Exception base class, and if the Exception passes the catch, it is going to caught the Format and Overflow exceptions.

		
	Handling All Exceptions
		
		- Unmanaged code can throw other exceptions, so in that we use the base Exception class

			try {
				// Code that can raise any exception
			}
			catch (Exception ex) {
				Console.WriteLine(ex.Message);
			}


			- The try-finally Statement

			try {
				// Code that can raise any exception
			}
			finally {
				// This block will always execute
			}

			- Ensures execution of a given block in all cases regardless of whether the try block raise an exception
			- Used for execution of cleaning-up code (releasing resources)


		- How Do Exceptions Work?

			try	-	Run this code
			catch	-	Execute this code when there is an exception
			finally	-	Always run this code


	Throwing Exceptions
	
		- Throwing exceptions is done by the throw keyword
		- Used to notify the calling code in case of an error or unusual situation
		- When exception is thrown
			- The program execution stops
			- The exception travels over the stack
				- Until a matching catch block is reached to handle it
		- Unhandled exceptions display an error message


		Throwing an exception with error message
			
			throw new ArguemntException("Invalid amount!");

		Exceptions can accept message and cause
			
			try {
				...
			}
			catch (SqlException sqlEx) {
				throw new InvalidOperationException("Cannot save invoice.", sqlEx);
			}
	
			- If the original exception (sqlEx) is not passed, the initial cause of the exception is lost

		Re-Throwing Exceptions (Caught Exceptions can be re-thrown again)

			try {
  				int.Parse(str);
			}
			catch (FormatException fe) {
  				Console.WriteLine("Parse failed!");
  				throw fe; // Re-throw the caught exception with new stack
			}
			catch (FormatException) {
  				throw; // Re-throw the last caught exception
			}
		
	
	Best Practices

		Using Catch Block
			
			- Catch blocks should
				- Begin with the exception lowest in the hierarchy
				- Continue with the more general exceptions
				- Otherwise a compilation error will occur
			- Each catch block should handle only the these exceptions which it expects
				- If a method is not competent to handle an exception, it should leave it unhandled
				- Handling all exceptions disregarding their type is a popular bad practice (anti-pattern)

		Choosing Exception Type

			- When an invalid parameter value is passed to a method
				- ArgumentException
				- ArgumentNullException
				- ArgumentOutOfRangeException

			- When requested operation is not supported
				- NotSupportedException

			- When a method is still not implemented
				- NotImplementedException

			- If no suitable standard exception class is available
				- Create own exception class by inheriting Exception base class

		Best Practices

			- When raising an exception, always pass to the constructor a good description of the problem as explanation message
			- The exception message should explain what causes the problem and how to solve it
				- Good: "Size should be integer in range [1...15]"
				- Good: "Invalid state. First call Initialize()"
				- Bad: "Unexpected error"
				- Bad: "Invalid argument"
			
			- Exceptions can decrease the application performance
				- Throw exceptions only in situatuions which are really exceptional and should be handled
				- Do not throw exceptions in the normal program control flow
				- CLR could throw exceptions at any time with no way to predict them (System.OutOfMemoryException)
		
		Create Custom Exception
		
			- Custom exceptions inherit an exception class (System.Exception base class)
			
				public class InvalidEgnException : Exception
				{
  					public InvalidEgnException(string msg): base(msg) 
					{ 
						// Exception 
					}
				}

			- Thrown just like any other exception
				
				throw new InvalidEgnException("Invalid EGN provided.");

	Summary
		- Exceptions provide a flexible error handling mechanism
		- Unhandled exceptions cause error messages
		- Try-finally ensures a given code block is always executed
			- Even when exception is thrown

	
